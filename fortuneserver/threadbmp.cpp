#include "threadbmp.h"
#include "qpushbutton.h"
#include <QImage>
#include <QLabel>
#include <QThread>
#include <Windows.h>
#include <fstream>
#include <iostream>
#include <server.h>
#include <stdio.h>
#include <vector>
using namespace std;
#pragma pack(2)
typedef struct tagBITMAPFILEHEADER3 {
  WORD bfType;
  DWORD bfSize;
  WORD bfReserved1;
  WORD bfReserved2;
  DWORD bfOffBits;
  // 文件头的偏移量表示，以字节为单位
} BitMapFileHeader; // BITMAPFILEHEADER;
#pragma pack()
typedef struct tagBITMAPINFOHEADER3 {
  DWORD biSize;
  LONG biWidth;
  LONG biHeight;
  WORD biPlanes;
  WORD
      biBitCount; //????????????????????????????????????????????????????????????的位数，必须�?????????????????????????????????????????????????????????????????????????1（双色），（29-30字节�?????????????????????????????????????????????????????????????????????????
  // 4(16色）�?????????????????????????????????????????????????????????????????????????8(256色）16(高彩�?????????????????????????????????????????????????????????????????????????)�?????????????????????????????????????????????????????????????????????????24（真彩色）之�?????????????????????????????????????????????????????????????????????????
  DWORD
  biCompression; // 位图压缩类型，必须是0（不压缩），�?????????????????????????????????????????????????????????????????????????31-34字节�?????????????????????????????????????????????????????????????????????????
  // 1(BI_RLE8压缩类型）或2(BI_RLE4压缩类型）之�?????????????????????????????????????????????????????????????????????????
  DWORD
  biSizeImage; // 位图的大�?????????????????????????????????????????????????????????????????????????(其中包含了为了补齐行数是4的�?�数而添加的空字�?????????????????????????????????????????????????????????????????????????)，以字节为单位（35-38字节�?????????????????????????????????????????????????????????????????????????
  LONG
      biXPelsPerMeter; // 位图水平分辨率，像素数（39-42字节�?????????????????????????????????????????????????????????????????????????
  LONG biYPelsPerMeter; // 位图垂直分辨率，像素数（43-46字节)
  DWORD
  biClrUsed; // 位图实际使用的颜色表中的颜色数（47-50字节�?????????????????????????????????????????????????????????????????????????
  DWORD
  biClrImportant; // 位图显示过程中重要的颜色数（51-54字节�?????????????????????????????????????????????????????????????????????????
} BitMapInfoHeader; // BITMAPINFOHEADER;
typedef struct tagRGBQUAD2 {
  BYTE rgbBlue;     // 蓝色的亮度（值范围为0-255)
  BYTE rgbGreen;    // 绿色的亮度（值范围为0-255)
  BYTE rgbRed;      // 红色的亮度（值范围为0-255)
  BYTE rgbReserved; // 保留，必须为0
} RgbQuad2;         // RGBQUAD;

void ThreadBmp::RGBtoBMP(QByteArray array, int width, int height, int index) {

  BitMapFileHeader
      bmfHdr; // 定义文件�?????????????????????????????????????????????????????????????????????????
  BitMapInfoHeader
      bmiHdr; // 定义信息�?????????????????????????????????????????????????????????????????????????
  RgbQuad2 bmiClr
      [3]; // 定义调色�?????????????????????????????????????????????????????????????????????????

  bmiHdr.biSize = sizeof(BitMapInfoHeader);
  bmiHdr.biWidth =
      width; // 指定图像的宽度，单位是像�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biHeight =
      height; // 指定图像的高度，单位是像�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biPlanes =
      1; // 目标设备的级别，必须�?????????????????????????????????????????????????????????????????????????1
  bmiHdr.biBitCount = 16; // 表示用到颜色时用到的位数
  // 16位表示高彩色�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biCompression = 3L; // BI_RGB仅有RGB555格式
  bmiHdr.biSizeImage =
      (width * height *
       2); // 指定实际位图�?????????????????????????????????????????????????????????????????????????占字节数
  bmiHdr.biXPelsPerMeter =
      0; // 水平分辨率，单位长度内的像素�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biYPelsPerMeter =
      0; // 垂直分辨率，单位长度内的像素�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biClrUsed =
      0; // 位图实际使用的彩色表中的颜色索引数（设为0的话，则说明使用�?????????????????????????????????????????????????????????????????????????有调色板项）
  bmiHdr.biClrImportant =
      0; // 说明对图象显示有重要影响的颜色索引的数目�?????????????????????????????????????????????????????????????????????????0表示�?????????????????????????????????????????????????????????????????????????有颜色都重要

  // RGB565格式掩码
  bmiClr[0].rgbBlue = 0;
  bmiClr[0].rgbGreen = 0xF8;
  bmiClr[0].rgbRed = 0;
  bmiClr[0].rgbReserved = 0;

  bmiClr[1].rgbBlue = 0xE0;
  bmiClr[1].rgbGreen = 0x07;
  bmiClr[1].rgbRed = 0;
  bmiClr[1].rgbReserved = 0;

  bmiClr[2].rgbBlue = 0x1F;
  bmiClr[2].rgbGreen = 0;
  bmiClr[2].rgbRed = 0;
  bmiClr[2].rgbReserved = 0;

  bmfHdr.bfType =
      (WORD)0x4D42; // 文件类型�?????????????????????????????????????????????????????????????????????????0x4D42也就是字�?????????????????????????????????????????????????????????????????????????'BM'
  bmfHdr.bfSize =
      (DWORD)(sizeof(BitMapFileHeader) + sizeof(BitMapInfoHeader) +
              sizeof(RgbQuad2) * 3 + bmiHdr.biSizeImage); // 文件大小
  bmfHdr.bfReserved1 = 0;                                 // 保留，必须为0
  bmfHdr.bfReserved2 = 0;                                 // 保留，必须为0
  bmfHdr.bfOffBits =
      (DWORD)(sizeof(BitMapFileHeader) + sizeof(BitMapInfoHeader) +
              sizeof(RgbQuad2) *
                  3); // 实际图像数据偏移�?????????????????????????????????????????????????????????????????????????
  BitMapFileHeader *bmfHdr1;
  bmfHdr1 = &bmfHdr;
  BitMapInfoHeader *bmiHdr1;
  bmiHdr1 = &bmiHdr;
  RgbQuad2 *bmiClr1;
  bmiClr1 = bmiClr;
  // cout<<to_string(m_socketDescriptor)+"_"+to_string(index)+"bmp"<<endl;
  ofstream outFile2(to_string(m_socketDescriptor) + "_" + to_string(index) +
                        ".bmp",
                    ios::out | ios::binary);
  outFile2.write((char *)bmfHdr1, sizeof(BitMapFileHeader));
  outFile2.write((char *)bmiHdr1, sizeof(BitMapInfoHeader));
  outFile2.write((char *)bmiClr1, sizeof(RgbQuad2) * 3);

  memcpy(bmp_raw, array, 614400);
  outFile2.write(bmp_raw, 614400);

  //     char test2[640*2+1];

  //    for(int i=0;i<height;i++){
  //      memcpy(test2,array.begin()+(width*i*2),640*2);
  //      outFile2.write(test2,640*2);
  //    }

  // 可以一次保存完毕

  outFile2.close();
}

ThreadBmp::ThreadBmp(qintptr descriptor, char *target) {
  m_socketDescriptor = descriptor;
  circle_times = 640 * 480 * 2 / 1400;
  last_bytes = 640 * 480 * 2 % 1400;
  if (last_bytes != 0)
    circle_times += 1;
  tcp_wnd = 0;
  step = 3;
  current_location = 0;
  dest = target;
  if_run = false;
}
void ThreadBmp::test() {
  cout << "hello this is run " << m_socketDescriptor << endl;
  receiver = new QTcpSocket;
  // enable stop button;
  //this->server->stopButton->setEnabled(true);
  receiver->setSocketDescriptor(m_socketDescriptor);
  connect(receiver, &QIODevice::readyRead, this, &ThreadBmp::readData);
  connect(receiver,&QTcpSocket::disconnected,this,&ThreadBmp::exitThread);
  QString ip = this->receiver->peerAddress().toString();

  emit this->updateServerCombo(ip);

  // server->bmpList->push_back(this);

  // receive_period(0, 3);
  // cout<<QThread::currentThreadId()<<endl;
}
void ThreadBmp::changeRunStatus() {
  QString ip = this->receiver->peerAddress().toString();
  if (ip == this->server->current_chose) {
    if_run = !if_run;
    cout << if_run << endl;
    if (if_run) {
        this->server->stopButton->setText("stop");
      receive_period(0, 3);
    }else{
      this->server->stopButton->setText("start");

    }
  }
}

void ThreadBmp::disconnect(){
  this->receiver->disconnectFromHost();
  exitThread();
}

void ThreadBmp::exitThread(){
  qDebug()<<"exit "<<QThread::currentThread();
  QString ip = this->receiver->peerAddress().toString();
  for(int i=0;i<this->server->clientCombo->count();++i){
    if(this->server->clientCombo->itemText(i)==ip){
      qDebug()<<"remove "<<ip;
      this->server->clientCombo->removeItem(i);
      break;
    }
  }
  QThread::currentThread()->exit(0);


}

std::vector<unsigned char> ThreadBmp::decode_array(int number) {
  int length = ceil(double(number) / 255);

  vector<unsigned char> deco_arr(4);

  for (int i = 0; i < 4; i++) {
    if (i < length - 1) {
      deco_arr[i] = 255;
    } else if (i == length - 1) {
      deco_arr[i] = number % 255;
    } else {
      deco_arr[i] = 0;
    }
    //   cout << int(deco_arr[i]) << " ";
  }
  // cout << endl;

  return deco_arr;
}
void ThreadBmp::receive_period(int start, int end) {

  QByteArray block;
  QDataStream out(&block, QIODevice::WriteOnly);
  out.setVersion(QDataStream::Qt_6_5);
  int number = start + circle_times + 1;
  vector<unsigned char> deco = decode_array(number);
  char o1[4];
  char *abs = (char *)o1;
  for (int i = 0; i < deco.size(); i++) {
    o1[i] = deco[i];
  }
  block = QByteArray::fromRawData(abs, sizeof(o1));
  out << *abs;

  receiver->write(block);
  if (end == circle_times && if_run == true) {
    current_location = -1;
  }
}
void ThreadBmp::changeRunComboSelect(const QString &name) {

  this->server->current_chose = name;
  QString ip = this->receiver->peerAddress().toString();
  qDebug() << ip;
  if (name == ip) {
   qDebug() << "hello world true";

    if_run = true;
    start=clock();
    receive_period(0, 3);


  } else {
    //qDebug() << "hello world";
    if_run = false;
  }
}
void ThreadBmp::readData() {
  QByteArray datagram = receiver->readAll();
  tcp_wnd += datagram.length();
  bmp.append(datagram);
  total_length += datagram.length();
  if (total_length == 614400) {
    end=clock();
    duration=(end-start)*1000/CLOCKS_PER_SEC;
    start=end;
   // qDebug()<<"receive duration"<<duration<<" ms";
    total_length = 0;
    memcpy(dest, bmp, 614400);

    QMetaObject::invokeMethod(this->server, "updateBmp",
                              Q_ARG(qintptr, m_socketDescriptor));
    this->index += 1;
    Server::syn += 1;

    bmp.clear();
  }
  if (tcp_wnd == 4200 || total_length == 0) {
    tcp_wnd = 0;
    current_location += 1;
    int start = current_location * step;
    int end = start + 3;
    if (end > circle_times) {
      end = circle_times;
    }
    if (if_run)
      receive_period(start, end);
  }
}
