// Copyright (C) 2017 The Qt Company Ltd.
// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR BSD-3-Clause

#include "server.h"
#include <QDataStream>
#include <QPixmap>
#include <QtCore>
#include <QtNetwork>
#include <QtWidgets>
#include <fstream>
#include <iostream>
#include <stdio.h>
using namespace std;
#pragma pack(2)
typedef struct tagBITMAPFILEHEADER3 {
  WORD bfType;
  DWORD bfSize;
  WORD bfReserved1;
  WORD bfReserved2;
  DWORD bfOffBits;
  // 文件头的偏移量表示，以字节为单位
} BitMapFileHeader; // BITMAPFILEHEADER;
#pragma pack()
typedef struct tagBITMAPINFOHEADER3 {
  DWORD biSize;
  LONG biWidth;
  LONG biHeight;
  WORD biPlanes;
  WORD
      biBitCount; //????????????????????????????????????????????????????????????的位数，必须�?????????????????????????????????????????????????????????????????????????1（双色），（29-30字节�?????????????????????????????????????????????????????????????????????????
  // 4(16色）�?????????????????????????????????????????????????????????????????????????8(256色）16(高彩�?????????????????????????????????????????????????????????????????????????)�?????????????????????????????????????????????????????????????????????????24（真彩色）之�?????????????????????????????????????????????????????????????????????????
  DWORD
      biCompression; // 位图压缩类型，必须是0（不压缩），�?????????????????????????????????????????????????????????????????????????31-34字节�?????????????????????????????????????????????????????????????????????????
  // 1(BI_RLE8压缩类型）或2(BI_RLE4压缩类型）之�?????????????????????????????????????????????????????????????????????????
  DWORD
      biSizeImage; // 位图的大�?????????????????????????????????????????????????????????????????????????(其中包含了为了补齐行数是4的�?�数而添加的空字�?????????????????????????????????????????????????????????????????????????)，以字节为单位（35-38字节�?????????????????????????????????????????????????????????????????????????
  LONG
      biXPelsPerMeter; // 位图水平分辨率，像素数（39-42字节�?????????????????????????????????????????????????????????????????????????
  LONG biYPelsPerMeter; // 位图垂直分辨率，像素数（43-46字节)
  DWORD
      biClrUsed; // 位图实际使用的颜色表中的颜色数（47-50字节�?????????????????????????????????????????????????????????????????????????
  DWORD
      biClrImportant; // 位图显示过程中重要的颜色数（51-54字节�?????????????????????????????????????????????????????????????????????????
} BitMapInfoHeader;   // BITMAPINFOHEADER;
typedef struct tagRGBQUAD2 {
  BYTE rgbBlue;     // 蓝色的亮度（值范围为0-255)
  BYTE rgbGreen;    // 绿色的亮度（值范围为0-255)
  BYTE rgbRed;      // 红色的亮度（值范围为0-255)
  BYTE rgbReserved; // 保留，必须为0
} RgbQuad2;         // RGBQUAD;

void Server::paintEvent(QPaintEvent *event) {}
Server::Server(QWidget *parent) : QWidget(parent), statusLabel(new QLabel) {
  statusLabel->setTextInteractionFlags(Qt::TextBrowserInteraction);

  model = new QSqlTableModel(this);
  std::cout << this << std::endl;
  model->setTable("words");
  model->setEditStrategy(QSqlTableModel::OnManualSubmit);
  model->select();
  model->setHeaderData(0, Qt::Horizontal, tr("ID"));
  model->setHeaderData(1, Qt::Horizontal, tr("First name"));
  model->setHeaderData(2, Qt::Horizontal, tr("Last name"));
  QTableView *view = new QTableView;
  view->setModel(model);
  view->resizeColumnsToContents();
  initServer();
  //! [2]
  fortunes << tr("You've been leading a dog's life. Stay off the furniture.")
           << tr("You've got to think about tomorrow.")
           << tr("You will be surprised by a loud noise.")
           << tr("You will feel hungry again in another hour.")
           << tr("You might have mail.")
           << tr("You cannot kill time without injuring eternity.")
           << tr("Computers are not intelligent. They only think they are.");
  //! [2]
  circle_times = 640 * 480 * 2 / 1400;
  last_bytes = 640 * 480 * 2 % 1400;
  if (last_bytes != 0)
    circle_times += 1;
  tcp_wnd = 0;
  step = 3;
  current_location = 0;
  bmpLabel = new QLabel;
  bmpLabel->setAlignment(Qt::AlignCenter);
  img = new QImage;
  img->load("1.bmp");
  bmpLabel->setPixmap(QPixmap::fromImage(*img));
  drawLabel = new QLabel;
  drawLabel->setAlignment(Qt::AlignCenter);
  draw = QImage(640, 480, QImage::Format_RGB16);
  QColor backColor = qRgb(240, 255, 255);

  draw.fill(backColor);
  drawLabel->setPixmap(QPixmap::fromImage(draw));

  auto quitButton = new QPushButton(tr("Quit"));

  quitButton->setAutoDefault(false);
  connect(quitButton, &QAbstractButton::clicked, this, &QWidget::close);
  //! [3]
  connect(tcpServer, &QTcpServer::newConnection, this, &Server::sendFortune);
  //! [3]

  auto buttonLayout = new QHBoxLayout;
  buttonLayout->addStretch(1);
  buttonLayout->addWidget(quitButton);
  buttonLayout->addStretch(1);
  auto bmpLayout = new QVBoxLayout;

  bmpLayout->addWidget(bmpLabel);
  bmpLayout->addWidget(drawLabel);
  QVBoxLayout *mainLayout = nullptr;
  if (QGuiApplication::styleHints()->showIsFullScreen() ||
      QGuiApplication::styleHints()->showIsMaximized()) {
    auto outerVerticalLayout = new QVBoxLayout(this);
    outerVerticalLayout->addItem(new QSpacerItem(
        0, 0, QSizePolicy::Ignored, QSizePolicy::MinimumExpanding));
    auto outerHorizontalLayout = new QHBoxLayout;
    outerHorizontalLayout->addItem(new QSpacerItem(
        0, 0, QSizePolicy::MinimumExpanding, QSizePolicy::Ignored));
    auto groupBox = new QGroupBox(QGuiApplication::applicationDisplayName());
    mainLayout = new QVBoxLayout(groupBox);
    outerHorizontalLayout->addWidget(groupBox);
    outerHorizontalLayout->addItem(new QSpacerItem(
        0, 0, QSizePolicy::MinimumExpanding, QSizePolicy::Ignored));
    outerVerticalLayout->addLayout(outerHorizontalLayout);
    outerVerticalLayout->addItem(new QSpacerItem(
        0, 0, QSizePolicy::Ignored, QSizePolicy::MinimumExpanding));
  } else {
    mainLayout = new QVBoxLayout(this);
  }

  mainLayout->addWidget(statusLabel);
  mainLayout->addLayout(buttonLayout);
  mainLayout->addLayout(bmpLayout);
  mainLayout->addWidget(view);

  setWindowTitle(QGuiApplication::applicationDisplayName());

  //this->setFixedSize(1000, 700);
}
void Server::receive_period(int start, int end) {

  // cout << circle_times << " circle time " << last_bytes << endl;
  QByteArray block;
  QDataStream out(&block, QIODevice::WriteOnly);
  out.setVersion(QDataStream::Qt_6_5);
  int number = start + circle_times + 1;
  vector<unsigned char> deco = decode_array(number);
  char o1[4];
  char *abs = (char *)o1;
  vector<unsigned char>::iterator it = deco.begin();
  for (int i = 0; i < deco.size(); i++) {
    o1[i] = deco[i];
  }
  block = QByteArray::fromRawData(abs, sizeof(o1));
  out << *abs;
  receiver->write(block);
  if (end == circle_times) {
    current_location = -1;
  }
}

std::vector<unsigned char> Server::decode_array(int number) {
  int length = ceil(double(number) / 255);

  vector<unsigned char> deco_arr(4);

  for (int i = 0; i < 4; i++) {
    if (i < length - 1) {
      deco_arr[i] = 255;
    } else if (i == length - 1) {
      deco_arr[i] = number % 255;
    } else {
      deco_arr[i] = 0;
    }
    //   cout << int(deco_arr[i]) << " ";
  }
  // cout << endl;

  return deco_arr;
}
void Server::RGBtoBMP(QByteArray array, int width, int height) {

  BitMapFileHeader
      bmfHdr; // 定义文件�?????????????????????????????????????????????????????????????????????????
  BitMapInfoHeader
      bmiHdr; // 定义信息�?????????????????????????????????????????????????????????????????????????
  RgbQuad2 bmiClr
      [3]; // 定义调色�?????????????????????????????????????????????????????????????????????????

  bmiHdr.biSize = sizeof(BitMapInfoHeader);
  bmiHdr.biWidth =
      width; // 指定图像的宽度，单位是像�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biHeight =
      height; // 指定图像的高度，单位是像�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biPlanes =
      1; // 目标设备的级别，必须�?????????????????????????????????????????????????????????????????????????1
  bmiHdr.biBitCount =
      16; // 表示用到颜色时用到的位数
          // 16位表示高彩色�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biCompression = 3L; // BI_RGB仅有RGB555格式
  bmiHdr.biSizeImage =
      (width * height *
       2); // 指定实际位图�?????????????????????????????????????????????????????????????????????????占字节数
  bmiHdr.biXPelsPerMeter =
      0; // 水平分辨率，单位长度内的像素�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biYPelsPerMeter =
      0; // 垂直分辨率，单位长度内的像素�?????????????????????????????????????????????????????????????????????????
  bmiHdr.biClrUsed =
      0; // 位图实际使用的彩色表中的颜色索引数（设为0的话，则说明使用�?????????????????????????????????????????????????????????????????????????有调色板项）
  bmiHdr.biClrImportant =
      0; // 说明对图象显示有重要影响的颜色索引的数目�?????????????????????????????????????????????????????????????????????????0表示�?????????????????????????????????????????????????????????????????????????有颜色都重要

  // RGB565格式掩码
  bmiClr[0].rgbBlue = 0;
  bmiClr[0].rgbGreen = 0xF8;
  bmiClr[0].rgbRed = 0;
  bmiClr[0].rgbReserved = 0;

  bmiClr[1].rgbBlue = 0xE0;
  bmiClr[1].rgbGreen = 0x07;
  bmiClr[1].rgbRed = 0;
  bmiClr[1].rgbReserved = 0;

  bmiClr[2].rgbBlue = 0x1F;
  bmiClr[2].rgbGreen = 0;
  bmiClr[2].rgbRed = 0;
  bmiClr[2].rgbReserved = 0;

  bmfHdr.bfType =
      (WORD)0x4D42; // 文件类型�?????????????????????????????????????????????????????????????????????????0x4D42也就是字�?????????????????????????????????????????????????????????????????????????'BM'
  bmfHdr.bfSize =
      (DWORD)(sizeof(BitMapFileHeader) + sizeof(BitMapInfoHeader) +
              sizeof(RgbQuad2) * 3 + bmiHdr.biSizeImage); // 文件大小
  bmfHdr.bfReserved1 = 0;                                 // 保留，必须为0
  bmfHdr.bfReserved2 = 0;                                 // 保留，必须为0
  bmfHdr.bfOffBits =
      (DWORD)(sizeof(BitMapFileHeader) + sizeof(BitMapInfoHeader) +
              sizeof(RgbQuad2) *
                  3); // 实际图像数据偏移�?????????????????????????????????????????????????????????????????????????
  BitMapFileHeader *bmfHdr1;
  bmfHdr1 = &bmfHdr;
  BitMapInfoHeader *bmiHdr1;
  bmiHdr1 = &bmiHdr;
  RgbQuad2 *bmiClr1;
  bmiClr1 = bmiClr;

  ofstream outFile2("1.bmp", ios::out | ios::binary);
  outFile2.write((char *)bmfHdr1, sizeof(BitMapFileHeader));
  outFile2.write((char *)bmiHdr1, sizeof(BitMapInfoHeader));
  outFile2.write((char *)bmiClr1, sizeof(RgbQuad2) * 3);

  memcpy(bmp_raw, array, 614400);
  outFile2.write(bmp_raw, 614400);

  //     char test2[640*2+1];

  //    for(int i=0;i<height;i++){
  //      memcpy(test2,array.begin()+(width*i*2),640*2);
  //      outFile2.write(test2,640*2);
  //    }

  // 可以一次保存完毕

  outFile2.close();

  return;
}
void Server::readData() {
  QByteArray datagram = receiver->readAll();
  tcp_wnd += datagram.length();
  bmp.append(datagram);
  total_length += datagram.length();
  if (total_length == 614400) {
    total_length = 0;
    cout << "bmp " << total_length << endl;
    RGBtoBMP(bmp, 640, 480);
    img->load("1.bmp");
    bmpLabel->setPixmap(QPixmap::fromImage(*img));

//    QPainter painter(&draw);
//    QPen myPen;
//    myPen.setWidth(25);
//    myPen.setColor(Qt::black);
//    painter.setPen(myPen);
//    painter.drawPoint(10, 10);
//    draw =QImage((unsigned char *)bmp_raw,640,480,QImage::Format_RGB16);

//    drawLabel->setPixmap(QPixmap::fromImage(draw));
    bmp.clear();
  }

  if (tcp_wnd == 4200 || total_length == 0) {
    tcp_wnd = 0;
    current_location += 1;
    int start = current_location * step;
    int end = start + 3;
    if (end > circle_times) {
      cout << "total length " << total_length << endl;

      end = circle_times;
    }

    receive_period(start, end);
  }
}

void Server::initServer() {
  //! [0] //! [1]
  tcpServer = new QTcpServer(this);

  if (!tcpServer->listen(QHostAddress("192.168.1.7"), 12345)) {
    QMessageBox::critical(
        this, tr("Fortune Server"),
        tr("Unable to start the server: %1.").arg(tcpServer->errorString()));
    close();
    return;
  }
  //! [0]
  QString ipAddress;
  const QList<QHostAddress> ipAddressesList = QNetworkInterface::allAddresses();
  // use the first non-localhost IPv4 address
  for (const QHostAddress &entry : ipAddressesList) {
    cout << entry.toString().toStdString() << endl;
    //        if (entry != QHostAddress::LocalHost && entry.toIPv4Address()) {
    //            ipAddress = entry.toString();
    //            break;
    //        }

    if (entry.toString().toStdString() == "192.168.1.7") {
      ipAddress = entry.toString();
      break;
    }
  }
  // if we did not find one, use IPv4 localhost
  if (ipAddress.isEmpty())
    ipAddress = QHostAddress(QHostAddress::LocalHost).toString();
  statusLabel->setText(tr("The server is running on\n\nIP: %1\nport: %2\n\n"
                          "Run the Fortune Client example now.")
                           .arg(ipAddress)
                           .arg(tcpServer->serverPort()));
  //! [1]
}

//! [4]
void Server::sendFortune() {

  cout << "hello new connection come" << endl;
  //! [5]
  QByteArray block;
  QDataStream out(&block, QIODevice::WriteOnly);
  out.setVersion(QDataStream::Qt_6_5);

  out << fortunes[QRandomGenerator::global()->bounded(fortunes.size())];
  //! [4] //! [7]

  QTcpSocket *clientConnection = tcpServer->nextPendingConnection();
  connect(clientConnection, &QAbstractSocket::disconnected, clientConnection,
          &QObject::deleteLater);
  //! [7] //! [8]

  // clientConnection->write(block);
  receiver = clientConnection;
  in.setDevice(receiver);
  in.setVersion(QDataStream::Qt_6_5);
  connect(receiver, &QIODevice::readyRead, this, &Server::readData);
  // current_location += 1;

  receive_period(0, 3);
  // emit QIODevice::readyRead
  // clientConnection->disconnectFromHost();
  //! [5]
}
//! [8]
